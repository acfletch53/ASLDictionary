# Using python 3

# For reading in the data from the website
import urllib.request
# For creating the XML
import xml.etree.ElementTree as ET # phone home
# For... turning the website data into *not* json...
import ast
# For making the XML less butt-ugly
import xml.dom.minidom
# Making GIFs like I'm not an internet n00b
import subprocess

"""
Here's an example of what we get from a call to the website:

[{"_id":"54dccfae0534b30f3cfef98f","id":"bg5MXVnk1vA","__v":3,"privacyStatus":"public","related_words":[],"keywords":["happy","happily","happiness","gaiety","gayety","gayly","gayness","gay","gaily","glad","gladly","gladness","merry","merrily","{1}","merriness","gladsome","rapt","raptly","raptness"],"thumbnailStandard":"https://i.ytimg.com/vi/bg5MXVnk1vA/sddefault.jpg","thumbnailHigh":"https://i.ytimg.com/vi/bg5MXVnk1vA/hqdefault.jpg","thumbnailMedium":"https://i.ytimg.com/vi/bg5MXVnk1vA/mqdefault.jpg","thumbnail":"https://i.ytimg.com/vi/bg5MXVnk1vA/default.jpg","description":"Please visit the Center for Accessible Technology in Sign \nwww.cats.gatech.edu","title":"happy,gay,glad,merry,rapt"}]

So actually the list of all of these is found at http://smartsign.imtc.gatech.edu/videos which makes my life a hell of a lot easier.

"""
def main():
    buildXML()

def createGif(url, title):
    title = title.replace(',', '-')
    # Creates the gif and uploads it to imgur
    imgur = subprocess.check_output('wgif ' + url + ' ' + title + '.gif' + ' --upload')
    # Voodoo magic to get the url of the gif
    # ... god I hope this works...
    return imgur.rsplit(' ', 1)[1]

def buildXML():
    # Namespace stuff
    ET.register_namespace("", "http://www.w3.org/1999/xhtml")
    # I want the d
    ET.register_namespace("d", "http://www.apple.com/DTDs/DictionaryService-1.0.rng")
    # I'm sorry, that was inappropriate.
    # TODO: Make the namespaces actully work/automatically tag things
    

    
    # Start that doc
    root = ET.Element('d:dictionary', {'xmlns':'http://www.w3.org/1999/xhtml', 'xmlns:d':'http://www.apple.com/DTDs/DictionaryService-1.0.rng'})
    
    # root.append(ET.Comment('Generated by ASLXMLGenerator.py for CATS'))
    
    # Now we go through and make an entry for every list in the webpage
    
    # Get the data from the webpage
    response = urllib.request.urlopen('http://smartsign.imtc.gatech.edu/videos')
    dict_data = response.read().decode('utf-8') # byte me
    dict_list = ast.literal_eval(dict_data)
    
    """
    _id -> some number
    id -> the number to append to https://www.youtube.com/embed/ to get the video
    __v -> no idea
    privacyStatus -> public|private
    related_words -> a list of strings of words related to this
    keywords -> a list of strings of words that should correspond to this video
    thumbnailStandard/High/Medium/ -> the first frame of the video in different sizes (as a .jpg)
    description -> The same for all of these (a link to the CATS site)
    title -> the title of the video
    """
    
    # Iterate through each dict/list
    for attr in dict_list:
        entry = ET.SubElement(root, 'd:entry', {'id':attr['_id'], 'd:title':attr['title']})
        # TODO: Prioritizing videos
        i = 1
        for keyword in attr['keywords']:
            index = ET.SubElement(entry, 'd:index', {'d:value':keyword})
        span = ET.SubElement(entry, 'span', {'class':'video'}) # This span is totally unnecessary
        # Gif it up
        """
        imgur = createGif('https://www.youtube.com/watch?v=' + attr['id'], attr['title'])
        img = ET.SubElement(span, 'img', {'src':imgur, 'alt':'GIF version of video available at ' + 'https://www.youtube.com/embed/' + attr['id']})
        """
        img = ET.SubElement(span, 'img', {'src':'https://media.giphy.com/media/sIIhZliB2McAo/giphy-facebook_s.jpg', 'alt':'GIF version of video available at ' + 'https://www.youtube.com/embed/' + attr['id']})
        if attr['related_words']:
            p = ET.SubElement(entry,'p')
            p.text = attr['related_words']
    
    tree = ET.ElementTree(root)
    tree.write("ASLDictionary.xml", encoding="UTF-8")
    x = xml.dom.minidom.parseString(ET.tostring(root))
    pretty_xml_as_string = x.toprettyxml()
    print(pretty_xml_as_string[0:1000])

if __name__ == "__main__":
    main()
